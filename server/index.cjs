const fs = require("fs");
const { exec } = require("child_process");
const express = require("express");
const app = express();
app.use(express.json());

const FIRMWARE_DIR = "/var/www/ar3s/firmware/avr/";
const SKETCH_DIR = "/tmp/test-sketch/";
const SKETCH_FILE = "sketch.ino";

app.post("/api/build/avr", (req, res) => {
  const { code, fqbn } = req.body;

  if (!fs.existsSync(SKETCH_DIR)) fs.mkdirSync(SKETCH_DIR, { recursive: true });
  if (!fs.existsSync(FIRMWARE_DIR)) fs.mkdirSync(FIRMWARE_DIR, { recursive: true });

  const sketchFilePath = `${SKETCH_DIR}${SKETCH_FILE}`;
  fs.writeFileSync(sketchFilePath, code);

  const buildCommand = `docker run --rm \
    -v ${SKETCH_DIR}:/work/sketch \
    -v ${FIRMWARE_DIR}:/work/build \
    arduino-cli-avr \
    compile --fqbn ${fqbn} --output-dir /work/build --warnings all /work/sketch/sketch.ino`;

  exec(buildCommand, (err, stdout, stderr) => {
    if (err) {
      console.error("Build failed:", stderr);
      return res.status(500).json({ error: "Compilation failed", details: stderr });
    }

    const hexFiles = fs.readdirSync(FIRMWARE_DIR)
      .filter((file) => file.endsWith(".hex"))
      .map((fileName) => ({
        fileName,
        fullPath: `${FIRMWARE_DIR}${fileName}`,
        updateTime: fs.statSync(`${FIRMWARE_DIR}${fileName}`).mtimeMs
      }))
      .sort((a, b) => b.updateTime - a.updateTime); // Sort by modified time desc

    const latestHex = hexFiles.length > 0 ? hexFiles[0].fileName : null;
    if (!latestHex) {
      return res.status(500).json({ error: "No HEX file produced" });
    }

    return res.json({
      artifactUrl: `/firmware/avr/${latestHex}`,
      log: stdout
    });
  });
});

// AI Copilot endpoint - simulates code generation
app.post("/api/copilot", (req, res) => {
  const { prompt, mode, existingCode } = req.body;
  
  if (!prompt) {
    return res.status(400).json({ error: "Prompt is required" });
  }

  // Simulate AI processing delay
  setTimeout(() => {
    let generatedCode = "";
    
    if (mode === "pinout") {
      // Generate pinout diagram as ASCII art or structured data
      generatedCode = `/*
 * PINOUT DIAGRAM
 * Generated by Athena AI
 * 
 * Arduino Uno/Nano Pin Configuration:
 * 
 * Digital Pins:
 * D0  (RX)  - Serial Receive
 * D1  (TX)  - Serial Transmit
 * D2-D13    - General Purpose I/O
 * D13       - Built-in LED
 * 
 * Analog Pins:
 * A0-A5     - Analog Input (can be used as digital I/O)
 * 
 * Power:
 * VIN       - Input Voltage (7-12V)
 * 5V        - 5V Output
 * 3.3V      - 3.3V Output
 * GND       - Ground
 * 
 * PWM Pins: ~D3, ~D5, ~D6, ~D9, ~D10, ~D11
 */

// Example pin configuration
const int LED_PIN = 13;
const int BUTTON_PIN = 2;
const int SENSOR_PIN = A0;

void setup() {
  pinMode(LED_PIN, OUTPUT);
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  pinMode(SENSOR_PIN, INPUT);
}`;
    } else if (mode === "debug") {
      // Debug mode - add debugging statements to existing code
      generatedCode = `// Athena AI Debug Suggestions:
// 1. Add Serial.begin(115200) in setup()
// 2. Add Serial.print() statements to track variable values
// 3. Check for common issues:

${existingCode || ""}

/*
 * DEBUG TIPS:
 * - Use Serial Monitor (115200 baud)
 * - Check pin connections
 * - Verify power supply voltage
 * - Look for timing issues in delays
 */`;
    } else {
      // Generate mode - create new code based on prompt
      generatedCode = `#include <Arduino.h>

// Generated by Athena AI
// Prompt: ${prompt}

void setup() {
  Serial.begin(115200);
  pinMode(LED_BUILTIN, OUTPUT);
  
  Serial.println("System initialized");
  Serial.println("Prompt: ${prompt}");
}

void loop() {
  // TODO: Implement your logic here
  digitalWrite(LED_BUILTIN, HIGH);
  delay(1000);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
  
  Serial.println("Running...");
}`;
    }

    res.json({
      success: true,
      code: generatedCode,
      mode: mode || "generate"
    });
  }, 1500); // Simulate AI processing time
});

// Start server
const port = process.env.PORT || 8081;
app.listen(port, () => {
  console.log(`Ar3s AVR build API listening on port ${port}`);
});
